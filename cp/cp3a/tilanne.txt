IDEOITA

materiaali: on ilmeisesti hyvä idea säilyttää sekä tavista ETTÄ transpoosia!
mun ei tarvii laskee koko dot productia kerralla. voin laskee osan tuloista eka, ja palata samaan kohtaan myöhemmin ja 
    lisätä sinne lukuja sitten

IDEA:
neliöitä inputista, NELIÖN KOKO? 2x2 neliöllä 4 tuloa
-> päddääminen: niin et on jaollinen kahdella
-> result matriisin iterointi
    alkaa: 0,2 row, col plussataan 2 raja on paddedin leveys / 2
-> epäjaollisten kanssa pärjääminen

testi 36 on aika hyvä tän deebugaamiseen!
1. paddaa kolmio niin että on kolmelle jaollista
    eihähn täs oo järkee koska emmävoi päddää resulttia mun pitäis päddää inputtii
    laske kaikki 3x3 neliöt resultissa kerralla, tee loput "ylijäämänä" sen jälkeen
2. pidä huoli että iteroit oikein
3. laske 9 kerralla
4. tadaa

transpoosi
    pointti niiku se että tulot on aina eri riveiltä, eli luetaan muistia miten sattuu
    idea: transpoosi, jolloin viereiset rivit mut sama sarake on vierekkäin muistissa. pitäis nopeutua mut ei nopeudu
        ongelma? iteroin nyt transpoosissa ensin sarakkeen sit rivin, en toisin päin. hidas ja huono
        transpoosi taitaa kusee siihen, että vektorit on kuiteski rivittäin. silti hypitään eessun taassun
        huono idea: riveittäin pistetulo

reuse data 
    idea: ota esim kolme riviä kerralla ja laske niiden kaikkia keskinäisiä pistetuloja samaan aikaan
    ongelma: mitkä pistetulot on laskettu mitkä ei menee aikas monimutkaiseksi
pystyiskö uudelleenkäyttää jotenki sarakkeiden suuntaisesti?

random ideoita 
    calculate many pixels in the result at one time 
        calculate many dot products at one time

openmp + vektorit 
test                    time  result
benchmarks/1.txt      0.116s  pass

  Your code used 0.116 sec of wallclock time, and 0.718 sec of CPU time
  ≈ you used 6.2 simultaneous hardware threads on average

benchmarks/2a.txt     1.135s  pass

  Your code used 1.135 sec of wallclock time, and 8.264 sec of CPU time
  ≈ you used 7.3 simultaneous hardware threads on average

benchmarks/2b.txt     1.149s  pass

  Your code used 1.149 sec of wallclock time, and 8.451 sec of CPU time
  ≈ you used 7.4 simultaneous hardware threads on average

benchmarks/2c.txt     1.005s  pass

  Your code used 1.005 sec of wallclock time, and 7.604 sec of CPU time
  ≈ you used 7.6 simultaneous hardware threads on average

benchmarks/2d.txt     1.266s  pass

  Your code used 1.266 sec of wallclock time, and 8.856 sec of CPU time
  ≈ you used 7.0 simultaneous hardware threads on average

>> ./cp benchmarks/3.txt
benchmarks/3.txt   [failed]